<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · QSM.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://kamesy.github.io/QSM.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QSM.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Phase-unwrapping"><span>Phase unwrapping</span></a></li><li><a class="tocitem" href="#Background-field-correction"><span>Background field correction</span></a></li><li><a class="tocitem" href="#Dipole-inversion"><span>Dipole inversion</span></a></li><li><a class="tocitem" href="#Binary-masks"><span>Binary masks</span></a></li><li><a class="tocitem" href="#Kernels"><span>Kernels</span></a></li><li><a class="tocitem" href="#Multi-echo"><span>Multi-echo</span></a></li><li><a class="tocitem" href="#Other"><span>Other</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kamesy/QSM.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><ul><li><a href="#API-Reference">API Reference</a></li><li class="no-marker"><ul><li><a href="#Index">Index</a></li><li><a href="#Phase-unwrapping">Phase unwrapping</a></li><li><a href="#Background-field-correction">Background field correction</a></li><li><a href="#Dipole-inversion">Dipole inversion</a></li><li><a href="#Binary-masks">Binary masks</a></li><li><a href="#Kernels">Kernels</a></li><li><a href="#Multi-echo">Multi-echo</a></li><li><a href="#Other">Other</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#QSM.bet"><code>QSM.bet</code></a></li><li><a href="#QSM.crop_indices"><code>QSM.crop_indices</code></a></li><li><a href="#QSM.crop_mask"><code>QSM.crop_mask</code></a></li><li><a href="#QSM.dipole_kernel"><code>QSM.dipole_kernel</code></a></li><li><a href="#QSM.erode_mask"><code>QSM.erode_mask</code></a></li><li><a href="#QSM.erode_mask!"><code>QSM.erode_mask!</code></a></li><li><a href="#QSM.fastfftsize"><code>QSM.fastfftsize</code></a></li><li><a href="#QSM.fit_echo_linear"><code>QSM.fit_echo_linear</code></a></li><li><a href="#QSM.fit_echo_linear!"><code>QSM.fit_echo_linear!</code></a></li><li><a href="#QSM.gradfp"><code>QSM.gradfp</code></a></li><li><a href="#QSM.gradfp!"><code>QSM.gradfp!</code></a></li><li><a href="#QSM.gradfp_adj"><code>QSM.gradfp_adj</code></a></li><li><a href="#QSM.gradfp_adj!"><code>QSM.gradfp_adj!</code></a></li><li><a href="#QSM.ismv"><code>QSM.ismv</code></a></li><li><a href="#QSM.lap"><code>QSM.lap</code></a></li><li><a href="#QSM.lap!"><code>QSM.lap!</code></a></li><li><a href="#QSM.laplace_kernel"><code>QSM.laplace_kernel</code></a></li><li><a href="#QSM.lbv"><code>QSM.lbv</code></a></li><li><a href="#QSM.nltv"><code>QSM.nltv</code></a></li><li><a href="#QSM.padarray!"><code>QSM.padarray!</code></a></li><li><a href="#QSM.padfastfft"><code>QSM.padfastfft</code></a></li><li><a href="#QSM.pdf"><code>QSM.pdf</code></a></li><li><a href="#QSM.psf2otf"><code>QSM.psf2otf</code></a></li><li><a href="#QSM.r2star_arlo"><code>QSM.r2star_arlo</code></a></li><li><a href="#QSM.r2star_crsi"><code>QSM.r2star_crsi</code></a></li><li><a href="#QSM.r2star_ll"><code>QSM.r2star_ll</code></a></li><li><a href="#QSM.r2star_numart2s"><code>QSM.r2star_numart2s</code></a></li><li><a href="#QSM.rts"><code>QSM.rts</code></a></li><li><a href="#QSM.sharp"><code>QSM.sharp</code></a></li><li><a href="#QSM.smv_kernel"><code>QSM.smv_kernel</code></a></li><li><a href="#QSM.tikh"><code>QSM.tikh</code></a></li><li><a href="#QSM.tkd"><code>QSM.tkd</code></a></li><li><a href="#QSM.tsvd"><code>QSM.tsvd</code></a></li><li><a href="#QSM.tv"><code>QSM.tv</code></a></li><li><a href="#QSM.unpadarray"><code>QSM.unpadarray</code></a></li><li><a href="#QSM.unpadarray!"><code>QSM.unpadarray!</code></a></li><li><a href="#QSM.unwrap_laplacian"><code>QSM.unwrap_laplacian</code></a></li><li><a href="#QSM.vsharp"><code>QSM.vsharp</code></a></li></ul><h2 id="Phase-unwrapping"><a class="docs-heading-anchor" href="#Phase-unwrapping">Phase unwrapping</a><a id="Phase-unwrapping-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-unwrapping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QSM.unwrap_laplacian" href="#QSM.unwrap_laplacian"><code>QSM.unwrap_laplacian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unwrap_laplacian(
    phas::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    solver::Symbol = :mgpcg
) -&gt; typeof(similar(phas))</code></pre><p>Laplacian phase unwrapping [1].</p><p>The Laplacian is computed using second order central finite differences on the complex phase. The resulting Poisson&#39;s equation can be solved with homogeneous Dirichlet (<code>solver = :mgpcg</code>), Neumann (<code>:dct</code>), or periodic (<code>:fft</code>) boundary conditions (BCs). Neumann and periodic BCs are imposed on the array while Dirichlet BCs are imposed on a region-of-interest (ROI) (<code>mask</code>). The boundary of the ROI is set such that values outside of it (<code>mask = 0</code>) are taken as boundary points and values inside of it (<code>mask = 1</code>) as interior points, ie. BC: <code>uphas[!mask] = 0</code>. This method combines phase unwrapping [1] and harmonic background field removing [2].</p><p><strong>Arguments</strong></p><ul><li><code>phas::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: wrapped (multi-echo) phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>solver::Symbol = :mgpcg</code>: solver for Poisson equation<ul><li><code>:dct</code>: homogeneous Neumann boundary condition on array</li><li><code>:fft</code>: periodic boundary condition on array</li><li><code>:mgpcg</code>: homogeneous Dirichlet boundary condition on <code>mask</code>   (multigrid-preconditioned conjugate gradient method)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(phas))</code>: unwrapped phase</li></ul><p><strong>References</strong></p><p>[1] Schofield MA, Zhu Y. Fast phase unwrapping algorithm for interferometric     applications. Optics letters. 2003 Jul 15;28(14):1194-6.</p><p>[2] Zhou D, Liu T, Spincemaille P, Wang Y. Background field removal by solving     the Laplacian boundary value problem. NMR in Biomedicine. 2014 Mar;27(3):312-9.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/unwrap/laplacian.jl#L1-L43">source</a></section></article><h2 id="Background-field-correction"><a class="docs-heading-anchor" href="#Background-field-correction">Background field correction</a><a id="Background-field-correction-1"></a><a class="docs-heading-anchor-permalink" href="#Background-field-correction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QSM.ismv" href="#QSM.ismv"><code>QSM.ismv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function ismv(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    r::Real = 2*maximum(vsz),
    tol::Real = 1e-3,
    maxit::Integer = 500,
    verbose::Bool = false,
) -&gt; Tuple{typeof(similar(f)), typeof(similar(mask))}</code></pre><p>Iterative spherical mean value method (iSMV) [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size for smv kernel</li></ul><p><strong>Keywords</strong></p><ul><li><code>r::Real = 2*maximum(vsz)</code>: radius of smv kernel in units of <code>vsz</code></li><li><code>tol::Real = 1e-3</code>: stopping tolerance</li><li><code>maxit::Integer = 500</code>: maximum number of iterations</li><li><code>verbose::Bool = false</code>: print convergence information</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: background corrected local field/phase</li><li><code>typeof(similar(mask))</code>: eroded binary mask</li></ul><p><strong>References</strong></p><p>[1] Wen Y, Zhou D, Liu T, Spincemaille P, Wang Y. An iterative spherical mean     value method for background field removal in MRI.  Magnetic resonance in     medicine. 2014 Oct;72(4):1065-71.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/bgremove/ismv.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.lbv" href="#QSM.lbv"><code>QSM.lbv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lbv(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    atol::Real = sqrt(eps(Float64)),
    rtol::Real = sqrt(eps(Float64)),
    maxit::Integer = maximum(size(f)),
    verbose::Bool = false
) -&gt; typeof(similar(f))</code></pre><p>Laplacian boundary value problem (LBV) [1].</p><p>The Laplacian is computed using second order central finite differences. The resulting Poisson&#39;s equation is then solved inside an ROI (<code>mask</code>) with homogenous Dirichlet boundary condition (BC) using a multigrid-preconditioned conjugate gradient method. The boundary of the ROI is set such that values outside of it (<code>mask = 0</code>) are taken as boundary points and values inside of it (<code>mask = 1</code>) as interior points, ie. BC: <code>fl[!mask] = 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>atol::Real = sqrt(eps(Float64))</code>: absolute stopping tolerance</li><li><code>rtol::Real = sqrt(eps(Float64))</code>: relative stopping tolerance</li><li><code>maxit::Integer = maximum(size(f))</code>: maximum number of cg iterations</li><li><code>verbose::Bool = false</code>: print convergence information</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: background corrected local field/phase</li></ul><p><strong>References</strong></p><p>[1] Zhou D, Liu T, Spincemaille P, Wang Y. Background field removal by solving     the Laplacian boundary value problem. NMR in Biomedicine. 2014 Mar;27(3):312-9.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/bgremove/lbv.jl#L21-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.pdf" href="#QSM.pdf"><code>QSM.pdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pdf(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    W::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, N)}} = nothing,
    pad::NTuple{3, Integer} = (0, 0, 0),
    bdir::NTuple{3, Real} = (0, 0, 1),
    Dkernel::Symbol = :i,
    lambda::Real = 0,
    tol::Real = 1e-5,
    maxit::Integer = ceil(sqrt(numel(mask))),
    verbose::Bool = false
) -&gt; typeof(similar(f))</code></pre><p>Projection onto dipole fields (PDF) [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size for dipole kernel</li></ul><p><strong>Keywords</strong></p><ul><li><code>W::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, N)}} = nothing</code>:   data fidelity weights</li><li><code>pad::NTuple{3, Integer} = (0, 0, 0)</code>: zero padding array<ul><li><code>&lt; 0</code>: no padding</li><li><code>≥ 0</code>: minimum padding to fast fft size</li></ul></li><li><code>bdir::NTuple{3, Real} = (0, 0, 1)</code>: unit vector of B field direction</li><li><code>Dkernel::Symbol = :i</code>: dipole kernel method</li><li><code>lambda::Real = 0</code>: regularization parameter</li><li><code>tol::Real = 1e-5</code>: stopping tolerance for iterative solver</li><li><code>maxit::Integer = ceil(sqrt(length(mask)))</code>: maximum number of iterations for   iterative solver</li><li><code>verbose::Bool = false</code>: print convergence information</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: background corrected local field/phase</li></ul><p><strong>References</strong></p><p>[1] Liu T, Khalidov I, de Rochefort L, Spincemaille P, Liu J, Tsiouris AJ,     Wang Y. A novel background field removal method for MRI using projection     onto dipole fields. NMR in Biomedicine. 2011 Nov;24(9):1129-36.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/bgremove/pdf.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.sharp" href="#QSM.sharp"><code>QSM.sharp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sharp(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    r::Real = 18*minimum(vsz),
    thr::Real = 0.05,
) -&gt; Tuple{typeof(similar(f)), typeof(similar(mask))}</code></pre><p>Sophisticated harmonic artifact reduction for phase data (SHARP) [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size for smv kernel</li></ul><p><strong>Keywords</strong></p><ul><li><code>r::Real = 18*minimum(vsz)</code>: radius of smv kernel in units of <code>vsz</code></li><li><code>thr::Real = 0.05</code>: threshold for high pass filter</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: background corrected local field/phase</li><li><code>typeof(similar(mask))</code>: eroded binary mask</li></ul><p><strong>References</strong></p><p>[1] Schweser F, Deistung A, Lehr BW, Reichenbach JR. Quantitative imaging of     intrinsic magnetic tissue properties using MRI signal phase: an approach to     in vivo brain iron metabolism?. Neuroimage. 2011 Feb 14;54(4):2789-807.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/bgremove/sharp.jl#L5-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.vsharp" href="#QSM.vsharp"><code>QSM.vsharp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vsharp(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    r::AbstractVector{&lt;:Real} = 18*minimum(vsz):-2*maximum(vsz):2*maximum(vsz),
    thr::Real = 0.05,
) -&gt; Tuple{typeof(similar(f)), typeof(similar(mask))}</code></pre><p>Variable kernels sophisticated harmonic artifact reduction for phase data (V-SHARP) [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size for smv kernel</li></ul><p><strong>Keywords</strong></p><ul><li><code>r::AbstractVector{&lt;:Real} = 18*minimum(vsz):-2*maximum(vsz):2*maximum(vsz)</code>:   radii of smv kernels in mm</li><li><code>thr::Real = 0.05</code>: threshold for high pass filter</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: background corrected local field/phase</li><li><code>typeof(similar(mask))</code>: eroded binary mask</li></ul><p><strong>References</strong></p><p>[1] Wu B, Li W, Guidon A, Liu C. Whole brain susceptibility mapping using     compressed sensing. Magnetic resonance in medicine. 2012 Jan;67(1):137-47.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/bgremove/sharp.jl#L141-L169">source</a></section></article><h2 id="Dipole-inversion"><a class="docs-heading-anchor" href="#Dipole-inversion">Dipole inversion</a><a id="Dipole-inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Dipole-inversion" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QSM.nltv" href="#QSM.nltv"><code>QSM.nltv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nltv(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    W::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, N)}} = nothing,
    Wtv::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, N)}} = nothing,
    pad::NTuple{3, Integer} = (0, 0, 0),
    Dkernel::Symbol = :k,
    bdir::NTuple{3, Real} = (0, 0, 1),
    lambda::Real = 1e-3,
    rho::Real = 100*lambda,
    mu::Real = 1,
    tol::Real = 1e-3,
    maxit::Integer = 250,
    toln::Real = 1e-6,
    maxitn::Integer = 10,
    verbose::Bool = false,
) -&gt; typeof(similar(f))</code></pre><p>Nonlinear total variation deconvolution using ADMM [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) local   field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>W::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, N)}} = nothing</code>:   data fidelity weights</li><li><code>Wtv::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, 5)}} = nothing</code>:   total variation weights<ul><li><code>M = 3</code>: same weights for all three gradient directions and all echoes</li><li><code>M = 4 = N</code>: same weights for all three gradient directions, different weights for echoes</li><li><code>M = 5, (size(Wtv)[4,5] = [1 or N, 3]</code>: different weights for each gradient direction</li></ul></li><li><code>pad::NTuple{3, Integer} = (0, 0, 0)</code>: zero padding array<ul><li><code>&lt; 0</code>: no padding</li><li><code>≥ 0</code>: minimum padding to fast fft size</li></ul></li><li><code>bdir::NTuple{3, Real} = (0, 0, 1)</code>: unit vector of B field direction</li><li><code>Dkernel::Symbol = :k</code>: dipole kernel method</li><li><code>lambda::Real = 1e-3</code>: regularization parameter</li><li><code>rho::Real = 100*lambda</code>: Lagrange multiplier penalty parameter</li><li><code>mu::Real = 1</code>: Lagrange multiplier penalty parameter (unused if <code>W = nothing</code>)</li><li><code>tol::Real = 1e-3</code>: stopping tolerance</li><li><code>maxit::Integer = 250</code>: maximum number of iterations</li><li><code>toln::Real = 1e-6</code>: stopping tolerance for Newton method</li><li><code>maxitn::Integer = 10</code>: maximum number of iterations for Newton method</li><li><code>verbose::Bool = false</code>: print convergence information</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: susceptibility map</li></ul><p><strong>References</strong></p><p>[1] Milovic C, Bilgic B, Zhao B, Acosta‐Cabronero J, Tejos C. Fast nonlinear     susceptibility inversion with variational regularization.     Magnetic resonance in medicine. 2018 Aug;80(2):814-21.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/inversion/nltv.jl#L1-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.rts" href="#QSM.rts"><code>QSM.rts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rts(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    pad::NTuple{3, Integer} = (0, 0, 0),
    Dkernel::Symbol = :k,
    bdir::NTuple{3, Real} = (0, 0, 1),
    lstol::Integer = 4,
    delta::Real = 0.15,
    mu::Real = 1e5,
    rho::Real = 10,
    tol::Real = 1e-2,
    maxit::Integer = 20,
    verbose::Bool = false,
) -&gt; typeof(similar(f))</code></pre><p>Rapid two-step dipole inversion with sparsity priors [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) local   field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>pad::NTuple{3, Integer} = (0, 0, 0)</code>: zero padding array<ul><li><code>&lt; 0</code>: no padding</li><li><code>≥ 0</code>: minimum padding to fast fft size</li></ul></li><li><code>bdir::NTuple{3, Real} = (0, 0, 1)</code>: unit vector of B field direction</li><li><code>Dkernel::Symbol = :k</code>: dipole kernel method</li><li><code>lstol::Integer = 4</code>: stopping tolerance (# of iterations) for lsmr solver</li><li><code>delta::Real = 0.15</code>: threshold for ill-conditioned k-space region</li><li><code>mu::Real = 1e5</code>: regularization parameter for tv minimization</li><li><code>rho::Real = 10</code>: Lagrange multiplier penalty parameter</li><li><code>tol::Real = 1e-2</code>: stopping tolerance</li><li><code>maxit::Integer = 20</code>: maximum number of iterations</li><li><code>verbose::Bool = false</code>: print convergence information</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: susceptibility map</li></ul><p><strong>References</strong></p><p>[1] Kames C, Wiggermann V, Rauscher A. Rapid two-step dipole inversion for     susceptibility mapping with sparsity priors.     Neuroimage. 2018 Feb 15;167:276-83.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/inversion/rts.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.tikh" href="#QSM.tikh"><code>QSM.tikh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tikh(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    pad::NTuple{3, Integer} = (0, 0, 0),
    bdir::NTuple{3, Real} = (0, 0, 1),
    Dkernel::Symbol = :k,
    lambda::Real = 1e-2,
    reg::Symbol = :gradient
) -&gt; typeof(similar(f))</code></pre><p>Tikhonov regularization [1].</p><p class="math-container">\[    argmin_x ||Dx - f||_2^2 + \frac{λ}{2}||Γx||_2^2\]</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) local   field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>pad::NTuple{3, Integer} = (0, 0, 0)</code>: zero padding array<ul><li><code>&lt; 0</code>: no padding</li><li><code>≥ 0</code>: minimum padding to fast fft size</li></ul></li><li><code>bdir::NTuple{3, Real} = (0, 0, 1)</code>: unit vector of B field direction</li><li><code>Dkernel::Symbol = :k</code>: dipole kernel method</li><li><code>lambda::Real = 1e-2</code>: regularization parameter</li><li><code>reg::Symbol = :identity</code>: regularization matrix Γ   (<code>:identity</code>, <code>:gradient</code>, <code>:laplacian</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: susceptibility map</li></ul><p><strong>References</strong></p><p>[1] Bilgic B, Chatnuntawech I, Fan AP, Setsompop K, Cauley SF, Wald LL,     Adalsteinsson E. Fast image reconstruction with L2‐regularization. Journal     of magnetic resonance imaging. 2014 Jul;40(1):181-91.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/inversion/direct.jl#L100-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.tkd" href="#QSM.tkd"><code>QSM.tkd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tkd(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    pad::NTuple{3, Integer} = (0, 0, 0),
    bdir::NTuple{3, Real} = (0, 0, 1),
    Dkernel::Symbol = :k,
    thr::Real = 0.15,
) -&gt; typeof(similar(f))</code></pre><p>Truncated k-space division (TKD) [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) local   field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>pad::NTuple{3, Integer} = (0, 0, 0)</code>: zero padding array<ul><li><code>&lt; 0</code>: no padding</li><li><code>≥ 0</code>: minimum padding to fast fft size</li></ul></li><li><code>bdir::NTuple{3, Real} = (0, 0, 1)</code>: unit vector of B field direction</li><li><code>Dkernel::Symbol = :k</code>: dipole kernel method</li><li><code>thr::Real = 0.15</code>: threshold for k-space filter</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: susceptibility map</li></ul><p><strong>References</strong></p><p>[1] Shmueli K, de Zwart JA, van Gelderen P, Li TQ, Dodd SJ, Duyn JH. Magnetic     susceptibility mapping of brain tissue in vivo using MRI phase data.     Magnetic Resonance in Medicine: An Official Journal of the International     Society for Magnetic Resonance in Medicine. 2009 Dec;62(6):1510-22.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/inversion/direct.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.tsvd" href="#QSM.tsvd"><code>QSM.tsvd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tsvd(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    pad::NTuple{3, Integer} = (0, 0, 0),
    bdir::NTuple{3, Real} = (0, 0, 1),
    Dkernel::Symbol = :k,
    thr::Real = 0.15,
) -&gt; typeof(similar(f))</code></pre><p>Truncated singular value decomposition (TSVD) [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) local   field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>pad::NTuple{3, Integer} = (0, 0, 0)</code>: zero padding array<ul><li><code>&lt; 0</code>: no padding</li><li><code>≥ 0</code>: minimum padding to fast fft size</li></ul></li><li><code>bdir::NTuple{3, Real} = (0, 0, 1)</code>: unit vector of B field direction</li><li><code>Dkernel::Symbol = :k</code>: dipole kernel method</li><li><code>thr::Real = 0.15</code>: threshold for k-space filter</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: susceptibility map</li></ul><p><strong>References</strong></p><p>[1] Wharton S, Schäfer A, Bowtell R. Susceptibility mapping in the human brain     using threshold‐based k‐space division. Magnetic resonance in medicine.     2010 May;63(5):1292-304.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/inversion/direct.jl#L51-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.tv" href="#QSM.tv"><code>QSM.tv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tv(
    f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)},
    mask::AbstractArray{Bool, 3},
    vsz::NTuple{3, Real};
    W::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, N)}} = nothing,
    Wtv::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, N)}} = nothing,
    pad::NTuple{3, Integer} = (0, 0, 0),
    Dkernel::Symbol = :k,
    bdir::NTuple{3, Real} = (0, 0, 1),
    lambda::Real = 1e-3,
    rho::Real = 100*lambda,
    mu::Real = 1,
    tol::Real = 1e-3,
    maxit::Integer = 250,
    verbose::Bool = false,
) -&gt; typeof(similar(f))</code></pre><p>Total variation deconvolution using ADMM [1].</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractArray{&lt;:AbstractFloat, N ∈ (3, 4)}</code>: unwrapped (multi-echo) local   field/phase</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask of region of interest</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>W::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, N)}} = nothing</code>:   data fidelity weights</li><li><code>Wtv::Union{Nothing, AbstractArray{&lt;:AbstractFloat, M ∈ (3, 5)}} = nothing</code>:   total variation weights<ul><li><code>M = 3</code>: same weights for all three gradient directions and all echoes</li><li><code>M = 4 = N</code>: same weights for all three gradient directions, different weights for echoes</li><li><code>M = 5, (size(Wtv)[4,5] = [1 or N, 3]</code>: different weights for each gradient direction</li></ul></li><li><code>pad::NTuple{3, Integer} = (0, 0, 0)</code>: zero padding array<ul><li><code>&lt; 0</code>: no padding</li><li><code>≥ 0</code>: minimum padding to fast fft size</li></ul></li><li><code>bdir::NTuple{3, Real} = (0, 0, 1)</code>: unit vector of B field direction</li><li><code>Dkernel::Symbol = :k</code>: dipole kernel method</li><li><code>lambda::Real = 1e-3</code>: regularization parameter</li><li><code>rho::Real = 100*lambda</code>: Lagrange multiplier penalty parameter</li><li><code>mu::Real = 1</code>: Lagrange multiplier penalty parameter (unused if <code>W = nothing</code>)</li><li><code>tol::Real = 1e-3</code>: stopping tolerance</li><li><code>maxit::Integer = 250</code>: maximum number of iterations</li><li><code>verbose::Bool = false</code>: print convergence information</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(f))</code>: susceptibility map</li></ul><p><strong>References</strong></p><p>[1] Bilgic B, Fan AP, Polimeni JR, Cauley SF, Bianciardi M, Adalsteinsson E,     Wald LL, Setsompop K. Fast quantitative susceptibility mapping with     L1‐regularization and automatic parameter selection.     Magnetic resonance in medicine. 2014 Nov;72(5):1444-59.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/inversion/tv.jl#L1-L55">source</a></section></article><h2 id="Binary-masks"><a class="docs-heading-anchor" href="#Binary-masks">Binary masks</a><a id="Binary-masks-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-masks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QSM.bet" href="#QSM.bet"><code>QSM.bet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bet(
    mag::AbstractArray{&lt;:Real, 3},
    vsz::NTuple{3, Real},
    betargs::AbstractString = &quot;-m -n -f 0.5&quot;
) -&gt; Array{Bool, 3}</code></pre><p>Interface to FSL&#39;s bet.</p><p><strong>Arguments</strong></p><ul><li><code>mag::AbstractArray{&lt;:Real, 3}</code>: magnitude image</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li><li><code>betargs::AbstractString = &quot;-m -n -f 0.5&quot;</code>: bet options</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Bool, 3}</code>: binary brain mask</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/fsl.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.crop_indices" href="#QSM.crop_indices"><code>QSM.crop_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crop_indices(x::AbstractArray, out::Number = 0) -&gt; CartesianIndices</code></pre><p>Indices to crop mask.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: mask</li><li><code>out::Number = 0</code>: value in <code>x</code> considered outside</li></ul><p><strong>Returns</strong></p><ul><li><code>CartesianIndices</code>: indices to crop mask</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L299-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.crop_mask" href="#QSM.crop_mask"><code>QSM.crop_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crop_mask(
    x::AbstractArray,
    m::AbstractArray = x;
    out::Number = 0
) -&gt; typeof(x[...])</code></pre><p>Crop array to mask.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: array to be cropped</li><li><code>m::AbstractArray</code>: mask</li></ul><p><strong>Keywords</strong></p><ul><li><code>out::Number = 0</code>: value in <code>m</code> considered outside</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(x[...])</code>: cropped array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L271-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.erode_mask" href="#QSM.erode_mask"><code>QSM.erode_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">erode_mask(mask::AbstractArray{Bool, 3}, iter::Integer = 1) -&gt; typeof(similar(mask))</code></pre><p>Erode binary mask using an 18-stencil cube.</p><p><strong>Arguments</strong></p><ul><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask</li><li><code>iter::Integer = 1</code>: erode <code>iter</code> times</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(mask))</code>: eroded binary mask</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L331-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.erode_mask!" href="#QSM.erode_mask!"><code>QSM.erode_mask!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">erode_mask!(
    emask::AbstractArray{Bool, 3},
    mask::AbstractArray{Bool, 3},
    iter::Integer = 1
) -&gt; emask</code></pre><p>Erode binary mask using an 18-stencil cube.</p><p><strong>Arguments</strong></p><ul><li><code>emask::AbstractArray{Bool, 3}</code>: eroded binary mask</li><li><code>mask::AbstractArray{Bool, 3}</code>: binary mask</li><li><code>iter::Integer = 1</code>: erode <code>iter</code> times</li></ul><p><strong>Returns</strong></p><ul><li><code>emask</code>: eroded binary mask</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L346-L362">source</a></section></article><h2 id="Kernels"><a class="docs-heading-anchor" href="#Kernels">Kernels</a><a id="Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Kernels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QSM.dipole_kernel" href="#QSM.dipole_kernel"><code>QSM.dipole_kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dipole_kernel(sz, vsz; kwargs...) =
    dipole_kernel(Float64, sz, vsz; kwargs...)

dipole_kernel(
    ::Type{T&lt;:AbstractFloat},
    sz::NTuple{3, Integer},
    vsz::NTuple{3, Real};
    bdir::NTuple{3, Real} = (0, 0, 1),
    method::Symbol = :kspace,
    dsz::NTuple{3, Integer} = sz,
    transform::Union{Nothing, Symbol} = nothing,
    shift::Bool = false
) -&gt; Array{T, 3}</code></pre><p>Dipole kernel.</p><p>By default the dipole kernel is constructed in k-space and centered at index <code>(1,1,1)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sz::NTuple{3, Integer}</code>: array size</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>bdir::NTuple{3, Real} = (0, 0, 1)</code>: unit vector of B field direction</li><li><code>method::Symbol = :kspace</code>: create in image space <code>(:i, :ispace)</code> or   kspace <code>(:k, :kspace)</code></li><li><code>dsz::NTuple{3, Integer} = sz</code>:<ul><li><code>method ∈ (:k, :kspace)</code>: unused</li><li><code>method ∈ (:i, :ispace)</code>: dipole kernel size in image space</li></ul></li><li><code>transform::Union{Nothing, Symbol} = nothing</code>:<ul><li><code>method ∈ (:k, :kspace)</code>: create <code>:rfft</code> or <code>:fft</code> kspace dipole kernel</li><li><code>method ∈ (:i, :ispace)</code>: transform image space dipole kernel <code>(:rfft, :fft)</code></li></ul></li><li><code>shift::Bool = false</code>:<ul><li><code>method ∈ (:k, :kspace)</code>:   kernel centered at <code>(1,1,1)</code> (<code>false</code>) or <code>N÷2+1</code> (<code>true</code>)</li><li><code>method ∈ (:i, :ispace) and transform = nothing</code>:   kernel centered at <code>N÷2+1</code> (<code>false</code>) or <code>(1,1,1)</code> (<code>true</code>)</li><li><code>method ∈ (:i, :ispace) and transform ∈ (:rfft, :fft)</code>:   kernel centered at <code>(1,1,1)</code> (<code>false</code>) or <code>N÷2+1</code> (<code>true</code>)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T, 3}</code>: dipole kernel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/kernels.jl#L5-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.laplace_kernel" href="#QSM.laplace_kernel"><code>QSM.laplace_kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">laplace_kernel(vsz) =
    laplace_kernel(Float64, vsz)

laplace_kernel(sz, vsz; kwargs...) =
    laplace_kernel(Float64, sz, vsz; kwargs...)

laplace_kernel(::Type{T&lt;:AbstractFloat}, vsz::NTuple{3, Real}) =
    laplace_kernel(T, (3, 3, 3), vsz, transform=nothing, shift=false)

laplace_kernel(
    ::Type{T&lt;:AbstractFloat},
    sz::NTuple{3, Integer},
    vsz::NTuple{3, Real};
    negative::Bool = false,
    transform::Union{Nothing, Symbol} = nothing,
    shift::Bool = false
) -&gt; Array{T, 3}</code></pre><p>Discrete 7-point stencil Laplacian kernel.</p><p><strong>Arguments</strong></p><ul><li><code>sz::NTuple{3, Integer}</code>: array size</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li></ul><p><strong>Keywords</strong></p><ul><li><code>negative::Bool = false</code>: construct negative Laplacian (<code>true</code>)</li><li><code>transform::Union{Nothing, Symbol} = nothing</code>:   transform Laplacian kernel <code>(:rfft, :fft)</code></li><li><code>shift::Bool = false</code>:<ul><li><code>transform = nothing</code>:   sphere centered at <code>N÷2+1</code> (<code>false</code>) or <code>(1,1,1)</code> (<code>true</code>)</li><li><code>transform ∈ (:rfft, :fft)</code>:   sphere centered at <code>(1,1,1)</code> (<code>false</code>) or <code>N÷2+1</code> (<code>true</code>)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T, 3}</code>: Laplacian kernel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/kernels.jl#L402-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.smv_kernel" href="#QSM.smv_kernel"><code>QSM.smv_kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smv_kernel(sz, vsz, r; kwargs...) =
    smv_kernel(Float64, sz, vsz, r; kwargs...)

smv_kernel(
    ::Type{T&lt;:AbstractFloat},
    sz::NTuple{3, Integer},
    vsz::NTuple{3, Real}
    r::Real;
    transform::Union{Nothing, Symbol} = nothing,
    shift::Bool = false
) -&gt; Array{T, 3}</code></pre><p>Spherical mean value kernel (SMV).</p><p><strong>Arguments</strong></p><ul><li><code>sz::NTuple{3, Integer}</code>: array size</li><li><code>vsz::NTuple{3, Real}</code>: voxel size</li><li><code>r::Real</code>: radius of sphere in units of <code>vsz</code></li></ul><p><strong>Keywords</strong></p><ul><li><code>transform::Union{Nothing, Symbol} = nothing</code>:   transform SMV kernel <code>(:rfft, :fft)</code></li><li><code>shift::Bool = false</code>:<ul><li><code>transform = nothing</code>:   sphere centered at <code>N÷2+1</code> (<code>false</code>) or <code>(1,1,1)</code> (<code>true</code>)</li><li><code>transform ∈ (:rfft, :fft)</code>:   sphere centered at <code>(1,1,1)</code> (<code>false</code>) or <code>N÷2+1</code> (<code>true</code>)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T, 3}</code>: SMV kernel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/kernels.jl#L237-L268">source</a></section></article><h2 id="Multi-echo"><a class="docs-heading-anchor" href="#Multi-echo">Multi-echo</a><a id="Multi-echo-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-echo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QSM.fit_echo_linear" href="#QSM.fit_echo_linear"><code>QSM.fit_echo_linear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_echo_linear(
    phas::AbstractArray{&lt;:AbstractFloat, N &gt; 1},
    W::AbstractArray{&lt;:AbstractFloat, N &gt; 1},
    TEs::NTuple{NT &gt; 1, Real};
    phase_offset::Bool = true
) -&gt; Tuple{typeof(similar(phas)){N-1}, [typeof(similar(phas)){N-1}]}</code></pre><p>Weighted least squares for multi-echo data.</p><p><strong>Arguments</strong></p><ul><li><code>phas::AbstractArray{&lt;:AbstractFloat, N &gt; 1}</code>: unwrapped multi-echo phase</li><li><code>W::AbstractArray{&lt;:AbstractFloat, N &gt; 1}</code>: reciprocal of error variance of voxel</li><li><code>TEs::NTuple{NT &gt; 1, Real}</code>: echo times</li></ul><p><strong>Keywords</strong></p><ul><li><code>phase_offset::Bool = true</code>: model phase offset (<code>true</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(phas)){N-1}</code>: weighted least-squares estimate for phase</li><li>[<code>typeof(similar(phas)){N-1}</code>]: weighted least-squares estimate for phase offset   if <code>phase_offset = true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/multi_echo.jl#L5-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.fit_echo_linear!" href="#QSM.fit_echo_linear!"><code>QSM.fit_echo_linear!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_echo_linear!(
    p::AbstractArray{&lt;:AbstractFloat, N},
    phas::AbstractArray{&lt;:AbstractFloat, M &gt; 1},
    W::AbstractArray{&lt;:AbstractFloat, M &gt; 1},
    TEs::NTuple{NT &gt; 1, Real}
) -&gt; p</code></pre><p>Weighted least squares for multi-echo data (phase offset = 0).</p><p><strong>Arguments</strong></p><ul><li><code>p::AbstractArray{&lt;:AbstractFloat, N}</code>: weighted least-squares estimate for phase</li><li><code>phas::AbstractArray{&lt;:AbstractFloat, M &gt; 1}</code>: unwrapped multi-echo phase</li><li><code>W::AbstractArray{&lt;:AbstractFloat, M &gt; 1}</code>: reciprocal of error variance of voxel</li><li><code>TEs::NTuple{NT &gt; 1, Real}</code>: echo times</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: weighted least-squares estimate for phase</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/multi_echo.jl#L45-L63">source</a></section><section><div><pre><code class="nohighlight hljs">fit_echo_linear!(
    p::AbstractArray{&lt;:AbstractFloat, N},
    p0::AbstractArray{&lt;:AbstractFloat, N},
    phas::AbstractArray{&lt;:AbstractFloat, M &gt; 1},
    W::AbstractArray{&lt;:AbstractFloat, M &gt; 1},
    TEs::NTuple{NT &gt; 1, Real}
) -&gt; (p, p0)</code></pre><p>Weighted least squares for multi-echo data (estimate phase offset).</p><p><strong>Arguments</strong></p><ul><li><code>p::AbstractArray{&lt;:AbstractFloat, N}</code>: weighted least-squares estimate for phase</li><li><code>p0::AbstractArray{&lt;:AbstractFloat, N}</code>: weighted least-squares estimate for phase offset</li><li><code>phas::AbstractArray{&lt;:AbstractFloat, M &gt; 1}</code>: unwrapped multi-echo phase</li><li><code>W::AbstractArray{&lt;:AbstractFloat, M &gt; 1}</code>: reciprocal of error variance of voxel</li><li><code>TEs::NTuple{NT &gt; 1, Real}</code>: echo times</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: weighted least-squares estimate for phase</li><li><code>p0</code>: weighted least-squares estimate for phase offset</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/multi_echo.jl#L101-L122">source</a></section></article><h2 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h2><h3 id="R2*-mapping"><a class="docs-heading-anchor" href="#R2*-mapping">R2* mapping</a><a id="R2*-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#R2*-mapping" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QSM.r2star_arlo" href="#QSM.r2star_arlo"><code>QSM.r2star_arlo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function r2star_arlo(
    mag::AbstractArray{&lt;:AbstractFloat, N &gt; 1},
    TEs::NTuple{NT &gt; 1, Real},
    mask::Union{Nothing, AbstractArray{Bool}} = nothing
) -&gt; typeof(similar(mag, size(mag)[1:N-1]))</code></pre><p>Auto-Regression on Linear Operations (ARLO) [1].</p><p><strong>Arguments</strong></p><ul><li><code>mag::AbstractArray{&lt;:AbstractFloat, N &gt; 1}</code>: multi-echo magnitude</li><li><code>TEs::NTuple{NT &gt; 1, Real}</code>: echo times</li><li><code>mask::Union{Nothing, AbstractArray{Bool}} = nothing</code>: binary mask of region of interest</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(mag, size(mag)[1:N-1]))</code>: R2* map (1 / units of TEs)</li></ul><p><strong>References</strong></p><p>[1] Pei M, Nguyen TD, Thimmappa ND, Salustri C, Dong F, Cooper MA, Li J,     Prince MR, Wang Y. Algorithm for fast monoexponential fitting based on     auto‐regression on linear operations (ARLO) of data.     Magnetic resonance in medicine. 2015 Feb;73(2):843-50.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/r2star.jl#L76-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.r2star_crsi" href="#QSM.r2star_crsi"><code>QSM.r2star_crsi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function r2star_crsi(
    mag::AbstractArray{&lt;:AbstractFloat, N &gt; 1},
    TEs::NTuple{NT &gt; 1, Real},
    mask::Union{Nothing, AbstractArray{Bool}} = nothing;
    M::Integer = 3,
    sigma::Union{Nothing, Real} = nothing,
    Rsz::NTuple{N-1, Integer} = size(mag)[1:N-1] .÷ 20,
) -&gt; typeof(similar(mag, size(mag)[1:N-1]))</code></pre><p>Calculation of Relaxivities by Signal Integration (CRSI) [1].</p><p><strong>Arguments</strong></p><ul><li><code>mag::AbstractArray{&lt;:AbstractFloat, N &gt; 1}</code>: multi-echo magnitude</li><li><code>TEs::NTuple{NT &gt; 1, Real}</code>: echo times</li><li><code>mask::Union{Nothing, AbstractArray{Bool}} = nothing</code>: binary mask of region of interest</li></ul><p><strong>Keywords</strong></p><ul><li><code>M::Integer = 3</code>: interpolation factor</li><li><code>sigma::Union{Nothing, Real} = nothing</code>: noise</li><li><code>Rsz::NTuple{N-1, Integer} = size(mag)[1:N-1] .÷ 20</code>:<ul><li><code>sigma isa Real</code>: unused</li><li><code>sigma isa Nothing</code>: size of kernels used to calculate the noise from the   background signal of the magnitude.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(mag, size(mag)[1:N-1]))</code>: R2* map (1 / units of TEs)</li></ul><p><strong>References</strong></p><p>[1] Song R, Loeffler RB, Holtrop JL, McCarville MB, Hankins JS, Hillenbrand CM.     Fast quantitative parameter maps without fitting: Integration yields     accurate mono‐exponential signal decay rates.     Magnetic resonance in medicine. 2018 Jun;79(6):2978-85.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/r2star.jl#L191-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.r2star_ll" href="#QSM.r2star_ll"><code>QSM.r2star_ll</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function r2star_ll(
    mag::AbstractArray{&lt;:AbstractFloat, N &gt; 1},
    TEs::NTuple{NT &gt; 1, Real},
    mask::Union{Nothing, AbstractArray{Bool}} = nothing
) -&gt; typeof(similar(mag, size(mag)[1:N-1]))</code></pre><p>Log-linear fit.</p><p><strong>Arguments</strong></p><ul><li><code>mag::AbstractArray{&lt;:AbstractFloat, N &gt; 1}</code>: multi-echo magnitude</li><li><code>TEs::NTuple{NT &gt; 1, Real}</code>: echo times</li><li><code>mask::Union{Nothing, AbstractArray{Bool}} = nothing</code>: binary mask of region of interest</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(mag, size(mag)[1:N-1]))</code>: R2* map (1 / units of TEs)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/r2star.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.r2star_numart2s" href="#QSM.r2star_numart2s"><code>QSM.r2star_numart2s</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function r2star_numart2s(
    mag::AbstractArray{&lt;:AbstractFloat, N &gt; 1},
    TEs::NTuple{NT &gt; 1, Real},
    mask::Union{Nothing, AbstractArray{Bool}} = nothing
) -&gt; typeof(similar(mag, size(mag)[1:N-1]))</code></pre><p>Numerical Algorithm for Real-time T2* mapping (NumART2*) [1].</p><p><strong>Arguments</strong></p><ul><li><code>mag::AbstractArray{&lt;:AbstractFloat, N &gt; 1}</code>: multi-echo magnitude</li><li><code>TEs::NTuple{NT &gt; 1, Real}</code>: echo times</li><li><code>mask::Union{Nothing, AbstractArray{Bool}} = nothing</code>: binary mask of region of interest</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(mag, size(mag)[1:N-1]))</code>: R2* map (1 / units of TEs)</li></ul><p><strong>References</strong></p><p>[1] Hagberg GE, Indovina I, Sanes JN, Posse S. Real‐time quantification of T2*     changes using multiecho planar imaging and numerical methods.     Magnetic Resonance in Medicine: An Official Journal of the International     Society for Magnetic Resonance in Medicine. 2002 Nov;48(5):877-82.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/r2star.jl#L345-L367">source</a></section></article><h3 id="Finite-differences"><a class="docs-heading-anchor" href="#Finite-differences">Finite differences</a><a id="Finite-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-differences" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QSM.gradfp" href="#QSM.gradfp"><code>QSM.gradfp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradfp(
    u::AbstractArray{&lt;:AbstractFloat, 3},
    h::NTuple{3, Real}
) -&gt; NTuple{3, typeof(similar(u))}</code></pre><p>First order forward difference gradient with periodic boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractArray{&lt;:AbstractFloat, 3}</code>: input array</li><li><code>h::NTuple{3, Real}</code>: grid spacing</li></ul><p><strong>Returns</strong></p><ul><li><code>dx::typeof(similar(u))</code>: x-component of gradient of <code>u</code></li><li><code>dy::typeof(similar(u))</code>: y-component of gradient of <code>u</code></li><li><code>dz::typeof(similar(u))</code>: z-component of gradient of <code>u</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/fd.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.gradfp!" href="#QSM.gradfp!"><code>QSM.gradfp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradfp!(
    dx::AbstractArray{&lt;:AbstractFloat, 3},
    dy::AbstractArray{&lt;:AbstractFloat, 3},
    dz::AbstractArray{&lt;:AbstractFloat, 3},
    u::AbstractArray{&lt;:AbstractFloat, 3},
    h::NTuple{3, Real},
) -&gt; (dx, dy, dz)</code></pre><p>First order forward difference gradient with periodic boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>dx::AbstractArray{&lt;:AbstractFloat, 3}</code>: x-component of gradient of <code>u</code></li><li><code>dy::AbstractArray{&lt;:AbstractFloat, 3}</code>: y-component of gradient of <code>u</code></li><li><code>dz::AbstractArray{&lt;:AbstractFloat, 3}</code>: z-component of gradient of <code>u</code></li><li><code>u::AbstractArray{&lt;:AbstractFloat, 3}</code>: input array</li><li><code>h::NTuple{3, Real}</code>: grid spacing</li></ul><p><strong>Returns</strong></p><ul><li><code>dx</code>: x-component of gradient of <code>u</code></li><li><code>dy</code>: y-component of gradient of <code>u</code></li><li><code>dz</code>: z-component of gradient of <code>u</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/fd.jl#L25-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.gradfp_adj" href="#QSM.gradfp_adj"><code>QSM.gradfp_adj</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradfp_adj(
    dx::AbstractArray{&lt;:AbstractFloat, 3},
    dy::AbstractArray{&lt;:AbstractFloat, 3},
    dz::AbstractArray{&lt;:AbstractFloat, 3},
    h::NTuple{3, Real}
) -&gt; typeof(similar(dx, promote_eltype(dx, dy, dz)))</code></pre><p>Adjoint of first order forward difference gradient with periodic boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>dx::AbstractArray{&lt;:AbstractFloat, 3}</code>: x-component</li><li><code>dy::AbstractArray{&lt;:AbstractFloat, 3}</code>: y-component</li><li><code>dz::AbstractArray{&lt;:AbstractFloat, 3}</code>: z-component</li><li><code>h::NTuple{3, Real}</code>: grid spacing</li></ul><p><strong>Returns</strong></p><ul><li><code>u::typeof(similar(dx, promote_eltype(dx, dy ,dz)))</code>: divergence of [dx, dy, dz]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/fd.jl#L119-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.gradfp_adj!" href="#QSM.gradfp_adj!"><code>QSM.gradfp_adj!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradfp_adj!(
    u::AbstractArray{&lt;:AbstractFloat, 3}
    dx::AbstractArray{&lt;:AbstractFloat, 3},
    dy::AbstractArray{&lt;:AbstractFloat, 3},
    dz::AbstractArray{&lt;:AbstractFloat, 3},
    h::NTuple{3, Real}
) -&gt; u</code></pre><p>Adjoint of first order forward difference gradient with periodic boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractArray{&lt;:AbstractFloat, 3}</code>: divergence of [dx, dy, dz]</li><li><code>dx::AbstractArray{&lt;:AbstractFloat, 3}</code>: x-component</li><li><code>dy::AbstractArray{&lt;:AbstractFloat, 3}</code>: y-component</li><li><code>dz::AbstractArray{&lt;:AbstractFloat, 3}</code>: z-component</li><li><code>h::NTuple{3, Real}</code>: grid spacing</li></ul><p><strong>Returns</strong></p><ul><li><code>u</code>: divergence of [dx, dy, dz]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/fd.jl#L148-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.lap" href="#QSM.lap"><code>QSM.lap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lap(
    u::AbstractArray{&lt;:AbstractFloat, 3},
    h::NTuple{3, Real}
) -&gt; typeof(similar(u))</code></pre><p>Second order central difference Laplacian.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractArray{&lt;:AbstractFloat, 3}</code>: input array</li><li><code>h::NTuple{3, Real}</code>: grid spacing</li></ul><p><strong>Returns</strong></p><ul><li><code>d2u::typeof(similar(u))</code>: discrete Laplacian of <code>u</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/fd.jl#L280-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.lap!" href="#QSM.lap!"><code>QSM.lap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lap!(
    d2u::AbstractArray{&lt;:AbstractFloat, 3},
    u::AbstractArray{&lt;:AbstractFloat, 3},
    h::NTuple{3, Real}
) -&gt; d2u</code></pre><p>Second order central difference Laplacian.</p><p><strong>Arguments</strong></p><ul><li><code>d2u::AbstractArray{&lt;:AbstractFloat, 3}</code>: discrete Laplacian of <code>u</code></li><li><code>u::AbstractArray{&lt;:AbstractFloat, 3}</code>: input array</li><li><code>h::NTuple{3, Real}</code>: grid spacing</li></ul><p><strong>Returns</strong></p><ul><li><code>d2u</code>: discrete Laplacian of <code>u</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/fd.jl#L298-L314">source</a></section></article><h3 id="Padding"><a class="docs-heading-anchor" href="#Padding">Padding</a><a id="Padding-1"></a><a class="docs-heading-anchor-permalink" href="#Padding" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QSM.fastfftsize" href="#QSM.fastfftsize"><code>QSM.fastfftsize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fastfftsize(
    sz::NTuple{N, Integer},
    ksz::NTuple{M, Integer} = ntuple(_ -&gt; 0, Val(N));
    rfft::Bool = false
) -&gt; NTuple{N, Integer}</code></pre><p>Next fast fft size greater than or equal to <code>sz</code> for convolution with a kernel of size <code>ksz</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray{T, N}</code>: array to pad</li><li><code>ksz::NTuple{M, Integer} = ntuple(_ -&gt; 0, Val(N))</code>: convolution kernel size<ul><li><code>ksz[n] &lt; 0</code>: no padding for dimension n</li></ul></li></ul><p><strong>Keywords</strong></p><ul><li><code>rfft::Bool = false</code>: force first dimension to be even (<code>true</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>NTuple{N, Integer}</code>: fast fft size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L19-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.padarray!" href="#QSM.padarray!"><code>QSM.padarray!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">padarray!(
    xp::AbstractArray{Txp, N},
    x::AbstractArray{Tx, N},
    pad::Symbol = :fill,
    val::Number = 0
) -&gt; xp</code></pre><p>Pad array keeping it centered at <code>n÷2+1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>xp::AbstractArray{Txp, N}</code>: padded array</li><li><code>x::AbstractArray{Tx, N}</code>: array to pad</li><li><code>pad::Symbol = :fill</code>: padding method<ul><li><code>:fill</code></li><li><code>:circular</code></li><li><code>:replicate</code></li><li><code>:symmetric</code></li><li><code>:reflect</code></li></ul></li><li><code>val::Number = 0</code>: pads array with <code>val</code> if <code>pad = :fill</code></li></ul><p><strong>Returns</strong></p><ul><li><code>xp</code>: padded array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L121-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.padfastfft" href="#QSM.padfastfft"><code>QSM.padfastfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">padfastfft(
    x::AbstractArray{T, N},
    ksz::NTuple{M, Integer} = ntuple(_ -&gt; 0, Val(N));
    pad::Symbol = :fill,
    val::Number = zero(T),
    rfft::Bool = false,
) -&gt; typeof(similar(x, szp))</code></pre><p>Pad array <code>x</code> to a fast fft size for convolution with a kernel of size <code>ksz</code>, keeping the array centered at <code>n÷2+1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray{T, N}</code>: array to pad</li><li><code>ksz::NTuple{M, Integer} = ntuple(_ -&gt; 0, Val(N))</code>: convolution kernel size<ul><li><code>ksz[n] &lt; 0</code>: no padding for dimension n</li></ul></li></ul><p><strong>Keywords</strong></p><ul><li><code>pad::Symbol = :fill</code>: padding method<ul><li><code>:fill</code></li><li><code>:circular</code></li><li><code>:replicate</code></li><li><code>:symmetric</code></li><li><code>:reflect</code></li></ul></li><li><code>val::Number = 0</code>: pads array with <code>val</code> if <code>pad = :fill</code></li><li><code>rfft::Bool = false</code>: force first dimension to be even (<code>true</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>typeof(similar(x, szp))</code>: padded array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L78-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.unpadarray" href="#QSM.unpadarray"><code>QSM.unpadarray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unpadarray(
    xp::AbstractArray{T, N},
    sz::NTuple{N, Integer}
) -&gt; typeof(similar(xp, sz))</code></pre><p>Extract array of size <code>sz</code> centered at <code>n÷2+1</code> from <code>xp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L226-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSM.unpadarray!" href="#QSM.unpadarray!"><code>QSM.unpadarray!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unpadarray!(
    x::AbstractArray{Tx, N},
    xp::AbstractArray{Txp, N},
    sz::NTuple{N, Integer}
) -&gt; x</code></pre><p>Extract array centered at <code>n÷2+1</code> from <code>xp</code> into <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L241-L249">source</a></section></article><h3 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QSM.psf2otf" href="#QSM.psf2otf"><code>QSM.psf2otf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">psf2otf(
    psf::AbstractArray{&lt;:Number, N},
    sz::NTuple{N, Integer} = size(psf);
    rfft::Bool = false,
) -&gt; otf</code></pre><p>Implementation of MATLAB&#39;s <code>psf2otf</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>psf::AbstractArray{T&lt;:Number, N}</code>: point-spread function</li><li><code>sz::NTuple{N, Integer}</code>: size of output array; must not be smaller than <code>psf</code></li></ul><p><strong>Keywords</strong></p><ul><li><code>rfft::Bool = false</code>:<ul><li><code>T&lt;:Real</code>: compute <code>fft</code> (<code>false</code>) or <code>rfft</code> (<code>true</code>)</li><li><code>T&lt;:Complex</code>: unused</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>otf</code>: optical transfer function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kamesy/QSM.jl/blob/2fb2914ac088c9653d3197a916ee94f597ebe4a7/src/utils/utils.jl#L418-L438">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.21 on <span class="colophon-date" title="Friday 22 July 2022 00:57">Friday 22 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
