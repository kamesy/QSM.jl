var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = QSM","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#Phase-unwrapping","page":"API Reference","title":"Phase unwrapping","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"unwrap_laplacian","category":"page"},{"location":"api/#QSM.unwrap_laplacian","page":"API Reference","title":"QSM.unwrap_laplacian","text":"unwrap_laplacian(\n    phas::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    solver::Symbol = :mgpcg\n) -> typeof(similar(phas))\n\nLaplacian phase unwrapping [1].\n\nThe Laplacian is computed using second order central finite differences on the complex phase. The resulting Poisson's equation can be solved with homogeneous Dirichlet (solver = :mgpcg), Neumann (:dct), or periodic (:fft) boundary conditions (BCs). Neumann and periodic BCs are imposed on the array while Dirichlet BCs are imposed on a region-of-interest (ROI) (mask). The boundary of the ROI is set such that values outside of it (mask = 0) are taken as boundary points and values inside of it (mask = 1) as interior points, ie. BC: uphas[!mask] = 0. This method combines phase unwrapping [1] and harmonic background field removing [2].\n\nArguments\n\nphas::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: wrapped (multi-echo) phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\nsolver::Symbol = :mgpcg: solver for Poisson equation\n:dct: homogeneous Neumann boundary condition on array\n:fft: periodic boundary condition on array\n:mgpcg: homogeneous Dirichlet boundary condition on mask   (multigrid-preconditioned conjugate gradient method)\n\nReturns\n\ntypeof(similar(phas)): unwrapped phase\n\nReferences\n\n[1] Schofield MA, Zhu Y. Fast phase unwrapping algorithm for interferometric     applications. Optics letters. 2003 Jul 15;28(14):1194-6.\n\n[2] Zhou D, Liu T, Spincemaille P, Wang Y. Background field removal by solving     the Laplacian boundary value problem. NMR in Biomedicine. 2014 Mar;27(3):312-9.\n\n\n\n\n\n","category":"function"},{"location":"api/#Background-field-correction","page":"API Reference","title":"Background field correction","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"ismv\nlbv\npdf\nsharp\nvsharp","category":"page"},{"location":"api/#QSM.ismv","page":"API Reference","title":"QSM.ismv","text":"function ismv(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    r::Real = 2*maximum(vsz),\n    tol::Real = 1e-3,\n    maxit::Integer = 500,\n    verbose::Bool = false,\n) -> Tuple{typeof(similar(f)), typeof(similar(mask))}\n\nIterative spherical mean value method (iSMV) [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size for smv kernel\n\nKeywords\n\nr::Real = 2*maximum(vsz): radius of smv kernel in units of vsz\ntol::Real = 1e-3: stopping tolerance\nmaxit::Integer = 500: maximum number of iterations\nverbose::Bool = false: print convergence information\n\nReturns\n\ntypeof(similar(f)): background corrected local field/phase\ntypeof(similar(mask)): eroded binary mask\n\nReferences\n\n[1] Wen Y, Zhou D, Liu T, Spincemaille P, Wang Y. An iterative spherical mean     value method for background field removal in MRI.  Magnetic resonance in     medicine. 2014 Oct;72(4):1065-71.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.lbv","page":"API Reference","title":"QSM.lbv","text":"lbv(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    atol::Real = sqrt(eps(Float64)),\n    rtol::Real = sqrt(eps(Float64)),\n    maxit::Integer = maximum(size(f)),\n    verbose::Bool = false\n) -> typeof(similar(f))\n\nLaplacian boundary value problem (LBV) [1].\n\nThe Laplacian is computed using second order central finite differences. The resulting Poisson's equation is then solved inside an ROI (mask) with homogenous Dirichlet boundary condition (BC) using a multigrid-preconditioned conjugate gradient method. The boundary of the ROI is set such that values outside of it (mask = 0) are taken as boundary points and values inside of it (mask = 1) as interior points, ie. BC: fl[!mask] = 0.\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\natol::Real = sqrt(eps(Float64)): absolute stopping tolerance\nrtol::Real = sqrt(eps(Float64)): relative stopping tolerance\nmaxit::Integer = maximum(size(f)): maximum number of cg iterations\nverbose::Bool = false: print convergence information\n\nReturns\n\ntypeof(similar(f)): background corrected local field/phase\n\nReferences\n\n[1] Zhou D, Liu T, Spincemaille P, Wang Y. Background field removal by solving     the Laplacian boundary value problem. NMR in Biomedicine. 2014 Mar;27(3):312-9.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.pdf","page":"API Reference","title":"QSM.pdf","text":"pdf(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    W::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, N)}} = nothing,\n    pad::NTuple{3, Integer} = (0, 0, 0),\n    bdir::NTuple{3, Real} = (0, 0, 1),\n    Dkernel::Symbol = :i,\n    lambda::Real = 0,\n    tol::Real = 1e-5,\n    maxit::Integer = ceil(sqrt(numel(mask))),\n    verbose::Bool = false\n) typeof(similar(f))\n\nProjection onto dipole fields (PDF) [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size for dipole kernel\n\nKeywords\n\nW::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, N)}} = nothing:   data fidelity weights\npad::NTuple{3, Integer} = (0, 0, 0): zero padding array\n< 0: no padding\n≥ 0: minimum padding to fast fft size\nbdir::NTuple{3, Real} = (0, 0, 1): unit vector of B field direction\nDkernel::Symbol = :i: dipole kernel method\nlambda::Real = 0: regularization parameter\ntol::Real = 1e-5: stopping tolerance for iterative solver\nmaxit::Integer = ceil(sqrt(length(mask))): maximum number of iterations for   iterative solver\nverbose::Bool = false: print convergence information\n\nReturns\n\ntypeof(similar(f)): background corrected local field/phase\n\nReferences\n\n[1] Liu T, Khalidov I, de Rochefort L, Spincemaille P, Liu J, Tsiouris AJ,     Wang Y. A novel background field removal method for MRI using projection     onto dipole fields. NMR in Biomedicine. 2011 Nov;24(9):1129-36.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.sharp","page":"API Reference","title":"QSM.sharp","text":"sharp(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    r::Real = 18*minimum(vsz),\n    thr::Real = 0.05,\n) -> Tuple{typeof(similar(f)), typeof(similar(mask))}\n\nSophisticated harmonic artifact reduction for phase data (SHARP) [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size for smv kernel\n\nKeywords\n\nr::Real = 18*minimum(vsz): radius of smv kernel in units of vsz\nthr::Real = 0.05: threshold for high pass filter\n\nReturns\n\ntypeof(similar(f)): background corrected local field/phase\ntypeof(similar(mask)): eroded binary mask\n\nReferences\n\n[1] Schweser F, Deistung A, Lehr BW, Reichenbach JR. Quantitative imaging of     intrinsic magnetic tissue properties using MRI signal phase: an approach to     in vivo brain iron metabolism?. Neuroimage. 2011 Feb 14;54(4):2789-807.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.vsharp","page":"API Reference","title":"QSM.vsharp","text":"vsharp(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    r::AbstractVector{<:Real} = 18*minimum(vsz):-2*maximum(vsz):2*maximum(vsz),\n    thr::Real = 0.05,\n) -> Tuple{typeof(similar(f)), typeof(similar(mask))}\n\nVariable kernels sophisticated harmonic artifact reduction for phase data (V-SHARP) [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size for smv kernel\n\nKeywords\n\nr::AbstractVector{<:Real} = 18*minimum(vsz):-2*maximum(vsz):2*maximum(vsz):   radii of smv kernels in mm\nthr::Real = 0.05: threshold for high pass filter\n\nReturns\n\ntypeof(similar(f)): background corrected local field/phase\ntypeof(similar(mask)): eroded binary mask\n\nReferences\n\n[1] Wu B, Li W, Guidon A, Liu C. Whole brain susceptibility mapping using     compressed sensing. Magnetic resonance in medicine. 2012 Jan;67(1):137-47.\n\n\n\n\n\n","category":"function"},{"location":"api/#Dipole-inversion","page":"API Reference","title":"Dipole inversion","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"nltv\nrts\ntikh\ntkd\ntsvd\ntv","category":"page"},{"location":"api/#QSM.nltv","page":"API Reference","title":"QSM.nltv","text":"nltv(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    W::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, N)}} = nothing,\n    Wtv::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, N)}} = nothing,\n    pad::NTuple{3, Integer} = (0, 0, 0),\n    Dkernel::Symbol = :k,\n    bdir::NTuple{3, Real} = (0, 0, 1),\n    lambda::Real = 1e-3,\n    rho::Real = 100*lambda,\n    mu::Real = 1,\n    tol::Real = 1e-3,\n    maxit::Integer = 250,\n    toln::Real = 1e-6,\n    maxitn::Integer = 10,\n    verbose::Bool = false,\n) -> typeof(similar(f))\n\nNonlinear total variation deconvolution using ADMM [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) local   field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\nW::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, N)}} = nothing:   data fidelity weights\nWtv::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, 5)}} = nothing:   total variation weights\nM = 3: same weights for all three gradient directions and all echoes\nM = 4 = N: same weights for all three gradient directions, different weights for echoes\nM = 5, (size(Wtv)[4,5] = [1 or N, 3]: different weights for each gradient direction\npad::NTuple{3, Integer} = (0, 0, 0): zero padding array\n< 0: no padding\n≥ 0: minimum padding to fast fft size\nbdir::NTuple{3, Real} = (0, 0, 1): unit vector of B field direction\nDkernel::Symbol = :k: dipole kernel method\nlambda::Real = 1e-3: regularization parameter\nrho::Real = 100*lambda: Lagrange multiplier penalty parameter\nmu::Real = 1: Lagrange multiplier penalty parameter (unused if W = nothing)\ntol::Real = 1e-3: stopping tolerance\nmaxit::Integer = 250: maximum number of iterations\ntoln::Real = 1e-6: stopping tolerance for Newton method\nmaxitn::Integer = 10: maximum number of iterations for Newton method\nverbose::Bool = false: print convergence information\n\nReturns\n\ntypeof(similar(f)): susceptibility map\n\nReferences\n\n[1] Milovic C, Bilgic B, Zhao B, Acosta‐Cabronero J, Tejos C. Fast nonlinear     susceptibility inversion with variational regularization.     Magnetic resonance in medicine. 2018 Aug;80(2):814-21.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.rts","page":"API Reference","title":"QSM.rts","text":"rts(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    pad::NTuple{3, Integer} = (0, 0, 0),\n    Dkernel::Symbol = :k,\n    bdir::NTuple{3, Real} = (0, 0, 1),\n    lstol::Integer = 4,\n    delta::Real = 0.15,\n    mu::Real = 1e5,\n    rho::Real = 10,\n    tol::Real = 1e-2,\n    maxit::Integer = 20,\n    verbose::Bool = false,\n) -> typeof(similar(f))\n\nRapid two-step dipole inversion with sparsity priors [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) local   field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\npad::NTuple{3, Integer} = (0, 0, 0): zero padding array\n< 0: no padding\n≥ 0: minimum padding to fast fft size\nbdir::NTuple{3, Real} = (0, 0, 1): unit vector of B field direction\nDkernel::Symbol = :k: dipole kernel method\nlstol::Integer = 4: stopping tolerance (# of iterations) for lsmr solver\ndelta::Real = 0.15: threshold for ill-conditioned k-space region\nmu::Real = 1e5: regularization parameter for tv minimization\nrho::Real = 10: Lagrange multiplier penalty parameter\ntol::Real = 1e-2: stopping tolerance\nmaxit::Integer = 20: maximum number of iterations\nverbose::Bool = false: print convergence information\n\nReturns\n\ntypeof(similar(f)): susceptibility map\n\nReferences\n\n[1] Kames C, Wiggermann V, Rauscher A. Rapid two-step dipole inversion for     susceptibility mapping with sparsity priors.     Neuroimage. 2018 Feb 15;167:276-83.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.tikh","page":"API Reference","title":"QSM.tikh","text":"tikh(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    pad::NTuple{3, Integer} = (0, 0, 0),\n    bdir::NTuple{3, Real} = (0, 0, 1),\n    Dkernel::Symbol = :k,\n    lambda::Real = 1e-2,\n    reg::Symbol = :gradient\n) -> typeof(similar(f))\n\nTikhonov regularization [1].\n\n    argmin_x Dx - f_2^2 + fracλ2Γx_2^2\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) local   field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\npad::NTuple{3, Integer} = (0, 0, 0): zero padding array   (-1 no padding, >= 0 mininum padding to fast fft size)\nbdir::NTuple{3, Real} = (0, 0, 1): unit vector of B field direction\nDkernel::Symbol = :k: dipole kernel method\nlambda::Real = 1e-2: regularization parameter\nreg::Symbol = :identity: regularization matrix Γ   (:identity, :gradient, :laplacian)\n\nReturns\n\ntypeof(similar(f)): susceptibility map\n\nReferences\n\n[1] Bilgic B, Chatnuntawech I, Fan AP, Setsompop K, Cauley SF, Wald LL,     Adalsteinsson E. Fast image reconstruction with L2‐regularization. Journal     of magnetic resonance imaging. 2014 Jul;40(1):181-91.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.tkd","page":"API Reference","title":"QSM.tkd","text":"tkd(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    pad::NTuple{3, Integer} = (0, 0, 0),\n    bdir::NTuple{3, Real} = (0, 0, 1),\n    Dkernel::Symbol = :k,\n    thr::Real = 0.15,\n) -> typeof(similar(f))\n\nTruncated k-space division (TKD) [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) local   field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\npad::NTuple{3, Integer} = (0, 0, 0): zero padding array   (-1 no padding, >= 0 mininum padding to fast fft size)\nbdir::NTuple{3, Real} = (0, 0, 1): unit vector of B field direction\nDkernel::Symbol = :k: dipole kernel method\nthr::Real = 0.15: threshold for k-space filter\n\nReturns\n\ntypeof(similar(f)): susceptibility map\n\nReferences\n\n[1] Shmueli K, de Zwart JA, van Gelderen P, Li TQ, Dodd SJ, Duyn JH. Magnetic     susceptibility mapping of brain tissue in vivo using MRI phase data.     Magnetic Resonance in Medicine: An Official Journal of the International     Society for Magnetic Resonance in Medicine. 2009 Dec;62(6):1510-22.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.tsvd","page":"API Reference","title":"QSM.tsvd","text":"tsvd(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    pad::NTuple{3, Integer} = (0, 0, 0),\n    bdir::NTuple{3, Real} = (0, 0, 1),\n    Dkernel::Symbol = :k,\n    thr::Real = 0.15,\n) -> typeof(similar(f))\n\nTruncated singular value decomposition (TSVD) [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) local   field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\npad::NTuple{3, Integer} = (0, 0, 0): zero padding array   (-1 no padding, >= 0 mininum padding to fast fft size)\nbdir::NTuple{3, Real} = (0, 0, 1): unit vector of B field direction\nDkernel::Symbol = :k: dipole kernel method\nthr::Real = 0.15: threshold for k-space filter\n\nReturns\n\ntypeof(similar(f)): susceptibility map\n\nReferences\n\n[1] Wharton S, Schäfer A, Bowtell R. Susceptibility mapping in the human brain     using threshold‐based k‐space division. Magnetic resonance in medicine.     2010 May;63(5):1292-304.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.tv","page":"API Reference","title":"QSM.tv","text":"tv(\n    f::AbstractArray{<:AbstractFloat, N ∈ (3, 4)},\n    mask::AbstractArray{Bool, 3},\n    vsz::NTuple{3, Real};\n    W::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, N)}} = nothing,\n    Wtv::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, N)}} = nothing,\n    pad::NTuple{3, Integer} = (0, 0, 0),\n    Dkernel::Symbol = :k,\n    bdir::NTuple{3, Real} = (0, 0, 1),\n    lambda::Real = 1e-3,\n    rho::Real = 100*lambda,\n    mu::Real = 1,\n    tol::Real = 1e-3,\n    maxit::Integer = 250,\n    verbose::Bool = false,\n) -> typeof(similar(f))\n\nTotal variation deconvolution using ADMM [1].\n\nArguments\n\nf::AbstractArray{<:AbstractFloat, N ∈ (3, 4)}: unwrapped (multi-echo) local   field/phase\nmask::AbstractArray{Bool, 3}: binary mask of region of interest\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\nW::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, N)}} = nothing:   data fidelity weights\nWtv::Union{Nothing, AbstractArray{<:AbstractFloat, M ∈ (3, 5)}} = nothing:   total variation weights\nM = 3: same weights for all three gradient directions and all echoes\nM = 4 = N: same weights for all three gradient directions, different weights for echoes\nM = 5, (size(Wtv)[4,5] = [1 or N, 3]: different weights for each gradient direction\npad::NTuple{3, Integer} = (0, 0, 0): zero padding array\n< 0: no padding\n≥ 0: minimum padding to fast fft size\nbdir::NTuple{3, Real} = (0, 0, 1): unit vector of B field direction\nDkernel::Symbol = :k: dipole kernel method\nlambda::Real = 1e-3: regularization parameter\nrho::Real = 100*lambda: Lagrange multiplier penalty parameter\nmu::Real = 1: Lagrange multiplier penalty parameter (unused if W = nothing)\ntol::Real = 1e-3: stopping tolerance\nmaxit::Integer = 250: maximum number of iterations\nverbose::Bool = false: print convergence information\n\nReturns\n\ntypeof(similar(f)): susceptibility map\n\nReferences\n\n[1] Bilgic B, Fan AP, Polimeni JR, Cauley SF, Bianciardi M, Adalsteinsson E,     Wald LL, Setsompop K. Fast quantitative susceptibility mapping with     L1‐regularization and automatic parameter selection.     Magnetic resonance in medicine. 2014 Nov;72(5):1444-59.\n\n\n\n\n\n","category":"function"},{"location":"api/#Binary-masks","page":"API Reference","title":"Binary masks","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"bet\ncrop_indices\ncrop_mask\nerode_mask\nerode_mask!","category":"page"},{"location":"api/#QSM.bet","page":"API Reference","title":"QSM.bet","text":"bet(\n    mag::AbstractArray{<:Real, 3},\n    vsz::NTuple{3, Real},\n    betargs::AbstractString = \"-m -n -f 0.5\"\n) -> Array{Bool, 3}\n\nInterface to FSL's bet.\n\nArguments\n\nmag::AbstractArray{<:Real, 3}: magnitude image\nvsz::NTuple{3, Real}: voxel size\nbetargs::AbstractString = \"-m -n -f 0.5\": bet options\n\nReturns\n\nArray{Bool, 3}: binary brain mask\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.crop_indices","page":"API Reference","title":"QSM.crop_indices","text":"crop_indices(x::AbstractArray, out::Number = 0) -> CartesianIndices\n\nIndices to crop mask.\n\nArguments\n\nx::AbstractArray: mask\nout::Number = 0: value in x considered outside\n\nReturns\n\nCartesianIndices: indices to crop mask\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.crop_mask","page":"API Reference","title":"QSM.crop_mask","text":"crop_mask(\n    x::AbstractArray,\n    m::AbstractArray = x;\n    out::Number = 0\n) -> typeof(x[...])\n\nCrop array to mask.\n\nArguments\n\nx::AbstractArray: array to be cropped\nm::AbstractArray: mask\n\nKeywords\n\nout::Number = 0: value in m considered outside\n\nReturns\n\ntypeof(x[...]): cropped array\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.erode_mask","page":"API Reference","title":"QSM.erode_mask","text":"erode_mask(mask::AbstractArray{Bool, 3}, iter::Integer = 1) -> typeof(similar(mask))\n\nErode binary mask using an 18-stencil cube.\n\nArguments\n\nmask::AbstractArray{Bool, 3}: binary mask\niter::Integer = 1: erode iter times\n\nReturns\n\ntypeof(similar(mask)): eroded binary mask\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.erode_mask!","page":"API Reference","title":"QSM.erode_mask!","text":"erode_mask(\n    emask::AbstractArray{Bool, 3},\n    mask::AbstractArray{Bool, 3},\n    iter::Integer = 1\n) -> emask\n\nErode binary mask using an 18-stencil cube.\n\nArguments\n\nemask::AbstractArray{Bool, 3}: eroded binary mask\nmask::AbstractArray{Bool, 3}: binary mask\niter::Integer = 1: erode iter times\n\nReturns\n\nemask: eroded binary mask\n\n\n\n\n\n","category":"function"},{"location":"api/#Kernels","page":"API Reference","title":"Kernels","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"dipole_kernel\nlaplace_kernel\nsmv_kernel","category":"page"},{"location":"api/#QSM.dipole_kernel","page":"API Reference","title":"QSM.dipole_kernel","text":"dipole_kernel(sz, vsz; kwargs...) =\n    dipole_kernel(Float64, sz, vsz; kwargs...)\n\ndipole_kernel(\n    ::Type{T<:AbstractFloat},\n    sz::NTuple{3, Integer},\n    vsz::NTuple{3, Real};\n    bdir::NTuple{3, Real} = (0, 0, 1),\n    method::Symbol = :kspace,\n    dsz::NTuple{3, Integer} = sz,\n    transform::Union{Nothing, Symbol} = nothing,\n    shift::Bool = false\n) -> Array{T, 3}\n\nDipole kernel.\n\nBy default the dipole kernel is constructed in k-space and centered at index (1,1,1).\n\nArguments\n\nsz::NTuple{3, Integer}: array size\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\nbdir::NTuple{3, Real} = (0, 0, 1): unit vector of B field direction\nmethod::Symbol = :kspace: create in image space (:i, :ispace) or   kspace (:k, :kspace)\ndsz::NTuple{3, Integer} = sz:\nmethod ∈ (:k, :kspace): unused\nmethod ∈ (:i, :ispace): dipole kernel size in image space\ntransform::Union{Nothing, Symbol} = nothing:\nmethod ∈ (:k, :kspace): create :rfft or :fft kspace dipole kernel\nmethod ∈ (:i, :ispace): transform image space dipole kernel (:rfft, :fft)\nshift::Bool = false:\nmethod ∈ (:k, :kspace):   kernel centered at (1,1,1) (false) or N÷2+1 (true)\nmethod ∈ (:i, :ispace) and transform = nothing:   kernel centered at N÷2+1 (false) or (1,1,1) (true)\nmethod ∈ (:i, :ispace) and transform ∈ (:rfft, :fft):   kernel centered at (1,1,1) (false) or N÷2+1 (true)\n\nReturns\n\nArray{T, 3}: dipole kernel\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.laplace_kernel","page":"API Reference","title":"QSM.laplace_kernel","text":"laplace_kernel(vsz) =\n    laplace_kernel(Float64, vsz)\n\nlaplace_kernel(sz, vsz; kwargs...) =\n    laplace_kernel(Float64, sz, vsz; kwargs...)\n\nlaplace_kernel(::Type{T<:AbstractFloat}, vsz::NTuple{3, Real}) =\n    laplace_kernel(T, (3, 3, 3), vsz, transform=nothing, shift=false)\n\nlaplace_kernel(\n    ::Type{T<:AbstractFloat},\n    sz::NTuple{3, Integer},\n    vsz::NTuple{3, Real};\n    negative::Bool = false,\n    transform::Union{Nothing, Symbol} = nothing,\n    shift::Bool = false\n) -> Array{T, 3}\n\nDiscrete 7-point stencil Laplacian kernel.\n\nArguments\n\nsz::NTuple{3, Integer}: array size\nvsz::NTuple{3, Real}: voxel size\n\nKeywords\n\nnegative::Bool = false: construct negative Laplacian (true)\ntransform::Union{Nothing, Symbol} = nothing:   transform Laplacian kernel (:rfft, :fft)\nshift::Bool = false:\ntransform = nothing:   sphere centered at N÷2+1 (false) or (1,1,1) (true)\ntransform ∈ (:rfft, :fft):   sphere centered at (1,1,1) (false) or N÷2+1 (true)\n\nReturns\n\nArray{T, 3}: Laplacian kernel\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.smv_kernel","page":"API Reference","title":"QSM.smv_kernel","text":"smv_kernel(sz, vsz, r; kwargs...) =\n    smv_kernel(Float64, sz, vsz, r; kwargs...)\n\nsmv_kernel(\n    ::Type{T<:AbstractFloat},\n    sz::NTuple{3, Integer},\n    vsz::NTuple{3, Real}\n    r::Real;\n    transform::Union{Nothing, Symbol} = nothing,\n    shift::Bool = false\n) -> Array{T, 3}\n\nSpherical mean value kernel (SMV).\n\nArguments\n\nsz::NTuple{3, Integer}: array size\nvsz::NTuple{3, Real}: voxel size\nr::Real: radius of sphere in units of vsz\n\nKeywords\n\ntransform::Union{Nothing, Symbol} = nothing:   transform SMV kernel (:rfft, :fft)\nshift::Bool = false:\ntransform = nothing:   sphere centered at N÷2+1 (false) or (1,1,1) (true)\ntransform ∈ (:rfft, :fft):   sphere centered at (1,1,1) (false) or N÷2+1 (true)\n\nReturns\n\nArray{T, 3}: SMV kernel\n\n\n\n\n\n","category":"function"},{"location":"api/#Multi-echo","page":"API Reference","title":"Multi-echo","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"fit_echo_linear\nfit_echo_linear!","category":"page"},{"location":"api/#QSM.fit_echo_linear","page":"API Reference","title":"QSM.fit_echo_linear","text":"fit_echo_linear(\n    phas::AbstractArray{<:AbstractFloat, 4},\n    W::AbstractArray{<:AbstractFloat, 4},\n    TEs::NTuple{N, Real};\n    phase_offset::Bool = true\n) -> NTuple{1 or 2, typeof(similar(phas)){3}}\n\nWeighted least squares for multi-echo data.\n\nArguments\n\nphas::AbstractArray{<:AbstractFloat, 4}: unwrapped multi-echo phase\nW::AbstractArray{<:AbstractFloat, 4}: reciprocal of error variance of voxel\nTEs::NTuple{N, Real}: echo times\n\nKeywords\n\nphase_offset::Bool = true: model phase offset (true)\n\nReturns\n\ntypeof(similar(phas)){3}: weighted least-squares estimate for phase\n[typeof(similar(phas)){3}]: weighted least-squares estimate for phase offset   if phase_offset = true\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.fit_echo_linear!","page":"API Reference","title":"QSM.fit_echo_linear!","text":"fit_echo_linear!(\n    p::AbstractArray{<:AbstractFloat, 3},\n    phas::AbstractArray{<:AbstractFloat, 4},\n    W::AbstractArray{<:AbstractFloat, 4},\n    TEs::NTuple{N, Real}\n) -> p\n\nWeighted least squares for multi-echo data (phase offset = 0).\n\nArguments\n\np::AbstractArray{<:AbstractFloat, 3}: weighted least-squares estimate for phase\nphas::AbstractArray{<:AbstractFloat, 4}: unwrapped multi-echo phase\nW::AbstractArray{<:AbstractFloat, 4}: reciprocal of error variance of voxel\nTEs::NTuple{N, Real}: echo times\n\nReturns\n\np: weighted least-squares estimate for phase\n\n\n\n\n\nfit_echo_linear!(\n    p::AbstractArray{<:AbstractFloat, 3},\n    p0::AbstractArray{<:AbstractFloat, 3},\n    phas::AbstractArray{<:AbstractFloat, 4},\n    W::AbstractArray{<:AbstractFloat, 4},\n    TEs::NTuple{N, Real}\n) -> (p, p0)\n\nWeighted least squares for multi-echo data (estimate phase offset).\n\nArguments\n\np::AbstractArray{<:AbstractFloat, 3}: weighted least-squares estimate for phase\np0::AbstractArray{<:AbstractFloat, 3}: weighted least-squares estimate for phase offset\nphas::AbstractArray{<:AbstractFloat, 4}: unwrapped multi-echo phase\nW::AbstractArray{<:AbstractFloat, 4}: reciprocal of error variance of voxel\nTEs::NTuple{N, Real}: echo times\n\nReturns\n\np: weighted least-squares estimate for phase\np0: weighted least-squares estimate for phase offset\n\n\n\n\n\n","category":"function"},{"location":"api/#Other","page":"API Reference","title":"Other","text":"","category":"section"},{"location":"api/#Finite-differences","page":"API Reference","title":"Finite differences","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"gradfp\ngradfp!\ngradfp_adj\ngradfp_adj!\nlap\nlap!","category":"page"},{"location":"api/#QSM.gradfp","page":"API Reference","title":"QSM.gradfp","text":"gradfp(\n    u::AbstractArray{<:AbstractFloat, 3},\n    h::NTuple{3, Real}\n) -> NTuple{3, typeof(similar(u))}\n\nFirst order forward difference gradient with periodic boundaries.\n\nArguments\n\nu::AbstractArray{<:AbstractFloat, 3}: input array\nh::NTuple{3, Real}: grid spacing\n\nReturns\n\ndx::typeof(similar(u)): x-component of gradient of u\ndy::typeof(similar(u)): y-component of gradient of u\ndz::typeof(similar(u)): z-component of gradient of u\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.gradfp!","page":"API Reference","title":"QSM.gradfp!","text":"gradfp!(\n    dx::AbstractArray{<:AbstractFloat, 3},\n    dy::AbstractArray{<:AbstractFloat, 3},\n    dz::AbstractArray{<:AbstractFloat, 3},\n    u::AbstractArray{<:AbstractFloat, 3},\n    h::NTuple{3, Real},\n) -> (dx, dy, dz)\n\nFirst order forward difference gradient with periodic boundaries.\n\nArguments\n\ndx::AbstractArray{<:AbstractFloat, 3}: x-component of gradient of u\ndy::AbstractArray{<:AbstractFloat, 3}: y-component of gradient of u\ndz::AbstractArray{<:AbstractFloat, 3}: z-component of gradient of u\nu::AbstractArray{<:AbstractFloat, 3}: input array\nh::NTuple{3, Real}: grid spacing\n\nReturns\n\ndx: x-component of gradient of u\ndy: y-component of gradient of u\ndz: z-component of gradient of u\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.gradfp_adj","page":"API Reference","title":"QSM.gradfp_adj","text":"gradfp_adj(\n    dx::AbstractArray{<:AbstractFloat, 3},\n    dy::AbstractArray{<:AbstractFloat, 3},\n    dz::AbstractArray{<:AbstractFloat, 3},\n    h::NTuple{3, Real}\n) -> typeof(similar(dx, promote_eltype(dx, dy, dz)))\n\nAdjoint of first order forward difference gradient with periodic boundaries.\n\nArguments\n\ndx::AbstractArray{<:AbstractFloat, 3}: x-component\ndy::AbstractArray{<:AbstractFloat, 3}: y-component\ndz::AbstractArray{<:AbstractFloat, 3}: z-component\nh::NTuple{3, Real}: grid spacing\n\nReturns\n\nu::typeof(similar(dx, promote_eltype(dx, dy ,dz))): divergence of [dx, dy, dz]\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.gradfp_adj!","page":"API Reference","title":"QSM.gradfp_adj!","text":"gradfp_adj!(\n    u::AbstractArray{<:AbstractFloat, 3}\n    dx::AbstractArray{<:AbstractFloat, 3},\n    dy::AbstractArray{<:AbstractFloat, 3},\n    dz::AbstractArray{<:AbstractFloat, 3},\n    h::NTuple{3, Real}\n) -> u\n\nAdjoint of first order forward difference gradient with periodic boundaries.\n\nArguments\n\nu::AbstractArray{<:AbstractFloat, 3}: divergence of [dx, dy, dz]\ndx::AbstractArray{<:AbstractFloat, 3}: x-component\ndy::AbstractArray{<:AbstractFloat, 3}: y-component\ndz::AbstractArray{<:AbstractFloat, 3}: z-component\nh::NTuple{3, Real}: grid spacing\n\nReturns\n\nu: divergence of [dx, dy, dz]\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.lap","page":"API Reference","title":"QSM.lap","text":"lap(\n    u::AbstractArray{<:AbstractFloat, 3},\n    h::NTuple{3, Real}\n) -> typeof(similar(u))\n\nSecond order central difference Laplacian.\n\nArguments\n\nu::AbstractArray{<:AbstractFloat, 3}: input array\nh::NTuple{3, Real}: grid spacing\n\nReturns\n\nd2u::typeof(similar(u)): discrete Laplacian of u\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.lap!","page":"API Reference","title":"QSM.lap!","text":"lap!(\n    d2u::AbstractArray{<:AbstractFloat, 3},\n    u::AbstractArray{<:AbstractFloat, 3},\n    h::NTuple{3, Real}\n) -> d2u\n\nSecond order central difference Laplacian.\n\nArguments\n\nd2u::AbstractArray{<:AbstractFloat, 3}: discrete Laplacian of u\nu::AbstractArray{<:AbstractFloat, 3}: input array\nh::NTuple{3, Real}: grid spacing\n\nReturns\n\nd2u: discrete Laplacian of u\n\n\n\n\n\n","category":"function"},{"location":"api/#Padding","page":"API Reference","title":"Padding","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"fastfftsize\npadarray!\npadfastfft\nunpadarray\nunpadarray!","category":"page"},{"location":"api/#QSM.fastfftsize","page":"API Reference","title":"QSM.fastfftsize","text":"fastfftsize(\n    sz::NTuple{N, Integer},\n    ksz::NTuple{M, Integer} = ntuple(_ -> 0, Val(N));\n    rfft::Bool = false\n) -> NTuple{N, Integer}\n\nNext fast fft size greater than or equal to sz for convolution with a kernel of size ksz.\n\nArguments\n\nx::AbstractArray{T, N}: array to pad\nksz::NTuple{M, Integer} = ntuple(_ -> 0, Val(N)): convolution kernel size\nksz[n] < 0: no padding for dimension n\n\nKeywords\n\nrfft::Bool = false: force first dimension to be even (true)\n\nReturns\n\nNTuple{N, Integer}: fast fft size\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.padarray!","page":"API Reference","title":"QSM.padarray!","text":"padarray!(\n    xp::AbstractArray{Txp, N},\n    x::AbstractArray{Tx, N},\n    pad::Symbol = :fill,\n    val::Number = 0\n) -> xp\n\nPad array keeping it centered at n÷2+1.\n\nArguments\n\nxp::AbstractArray{Txp, N}: padded array\nx::AbstractArray{Tx, N}: array to pad\npad::Symbol = :fill: padding method\n:fill\n:circular\n:replicate\n:symmetric\n:reflect\nval::Number = 0: pads array with val if pad = :fill\n\nReturns\n\nxp: padded array\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.padfastfft","page":"API Reference","title":"QSM.padfastfft","text":"padfastfft(\n    x::AbstractArray{T, N},\n    ksz::NTuple{M, Integer} = ntuple(_ -> 0, Val(N));\n    pad::Symbol = :fill,\n    val::Number = zero(T),\n    rfft::Bool = false,\n) -> typeof(similar(x, szp))\n\nPad array x to a fast fft size for convolution with a kernel of size ksz, keeping the array centered at n÷2+1.\n\nArguments\n\nx::AbstractArray{T, N}: array to pad\nksz::NTuple{M, Integer} = ntuple(_ -> 0, Val(N)): convolution kernel size\nksz[n] < 0: no padding for dimension n\n\nKeywords\n\npad::Symbol = :fill: padding method\n:fill\n:circular\n:replicate\n:symmetric\n:reflect\nval::Number = 0: pads array with val if pad = :fill\nrfft::Bool = false: force first dimension to be even (true)\n\nReturns\n\ntypeof(similar(x, szp)): padded array\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.unpadarray","page":"API Reference","title":"QSM.unpadarray","text":"unpadarray(\n    xp::AbstractArray{T, N},\n    sz::NTuple{N, Integer}\n) -> typeof(similar(xp, sz))\n\nExtract array of size sz centered at n÷2+1 from xp.\n\n\n\n\n\n","category":"function"},{"location":"api/#QSM.unpadarray!","page":"API Reference","title":"QSM.unpadarray!","text":"unpadarray!(\n    x::AbstractArray{Tx, N},\n    xp::AbstractArray{Txp, N},\n    sz::NTuple{N, Integer}\n) -> x\n\nExtract array centered at n÷2+1 from xp into x.\n\n\n\n\n\n","category":"function"},{"location":"api/#Miscellaneous","page":"API Reference","title":"Miscellaneous","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"psf2otf","category":"page"},{"location":"api/#QSM.psf2otf","page":"API Reference","title":"QSM.psf2otf","text":"psf2otf(\n    psf::AbstractArray{<:Number, N},\n    sz::NTuple{N, Integer} = size(psf);\n    rfft::Bool = false,\n) -> otf\n\nImplementation of MATLAB's psf2otf function.\n\nArguments\n\npsf::AbstractArray{T<:Number, N}: point-spread function\nsz::NTuple{N, Integer}: size of output array; must not be smaller than psf\n\nKeywords\n\nrfft::Bool = false:\nT<:Real: compute fft (false) or rfft (true)\nT<:Complex: unused\n\nReturns\n\notf: optical transfer function\n\n\n\n\n\n","category":"function"},{"location":"#QSM.jl","page":"Home","title":"QSM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia toolbox for quantitative susceptibility mapping (QSM).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QSM.jl requires Julia v1.6 or later.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add https://github.com/kamesy/QSM.jl","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using QSM\n\n# constants\nγ = 267.52      # gyromagnetic ratio\nB0 = 3          # main magnetic field strength\n\n# load 3D single-, or multi-echo data using your favourite\n# package, e.g. MAT.jl, NIfTI.jl, ParXRec.jl, ...\nmag, phas = ...\n\nvsz = (...,)    # voxel size\nTEs = (...,)    # echo times\nbdir = (...,)   # direction of B-field\n\n# extract brain mask from last echo using FSL's bet\nmask0 = bet(@view(mag[:,:,:,end]), vsz, \"-m -n -f 0.5\")\n\n# erode mask\nmask1 = erode_mask(mask0, 5)\n\n# unwrap phase + harmonic background field correction\nuphas = unwrap_laplacian(phas, mask1, vsz)\n\n# convert units\nfor t in axes(uphas, 4)\n    for R in CartesianIndices(axes(uphas)[1:3])\n        uphas[R,t] *= inv(B0 * γ * TEs[t])\n    end\nend\n\n# remove non-harmonic background fields\nfl, mask2 = vsharp(uphas, mask1, vsz)\n\n# dipole inversion\nx = rts(fl, mask2, vsz, bdir=bdir)","category":"page"},{"location":"#Multi-Threading","page":"Home","title":"Multi-Threading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multi-threading is provided by Polyester.jl. To enable threading, start Julia with multiple threads:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --threads N","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"export JULIA_NUM_THREADS=N","category":"page"},{"location":"","page":"Home","title":"Home","text":"After an interrupt of a multi-threaded loop, reset threading via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> QSM.reset_threading()","category":"page"}]
}
